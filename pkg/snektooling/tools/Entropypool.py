# -*- coding: utf-8 -*-
#!/usr/bin/python3.9
################################################################################
##       Entropy Pool for learning/hacking - Vintage 2021 Python 3.9         ##
################################################################################                
# Licenced under GPLv3-modified                                               ##
# https://www.gnu.org/licenses/gpl-3.0.en.html                                ##
#                                                                             ##
# The above copyright notice and this permission notice shall be included in  ##
# all copies or substantial portions of the Software.                         ##
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
################################################################################
__docs__ = """Entropy Pool For the generation of Cryptographically Secure Pseudo Random Numbers

https://en.wikipedia.org/wiki/Entropy_(information_theory)

This tutorial uses code from the following sources:
https://github.com/yinengy/Mersenne-Twister-in-Python
https://github.com/AllenDowney/PythonCounterPmf/

    the needed effort usually multiplies with the digest length, even a thousand-fold
    advantage in processing power can be neutralized by adding a few dozen bits to the latter. 
    
Claude Shannon's definition of self-information was chosen to meet several axioms:
    - An event with probability 100% is perfectly unsurprising and yields no information.
    - The less probable an event is, the more surprising it is and the more information it yields.
    - If two independent events are measured separately, the total amount of information 
      is the sum of the self-informations of the individual events.
""" 
#t = Timer(...)       # outside the try/except
#try:
#    t.timeit(...)    # or t.repeat(...)
#except Exception:
#    t.print_exc()
# I have no fucking idea what I am doing
TESTING = True
DEBUG = True
import hmac
import time
import numpy
import sys,os
import hashlib
import secrets
import cryptography
from binascii import hexlify
from collections import Counter
from cryptography.fernet import Fernet

#local imports
from src.util.Utils import source1
from src.util.Utils import redprint,greenprint,blueprint,makeyellow,errorprinter
from src.MersenneTwist import MersenneTwist
from src.XORshift import XORShift
from src.ProbabilityMassFunction import MassProbabilityFunction

# the idea of this is to have multiple sources of randomness and 
# XOR/HMAC them into a single byte array of fixed length for the purposes of 
# CSPRNG
class FakePool():
    def __init__(self, poolsize = 64):
        '''Fake entropy pool to test the Testing functions
    Uses a sha256 hash in a "counter mode" 
    I.E, it counts up from 0 and encodes each number 
    from 0 to whatever you set as the limit'''
        self.poolsize = poolsize
        self.poolofrealrandos = []
        self.poolofsha256randos = []
        #self.fillthepoolSHA256CounterMode(self.poolsize)
        #self.fillthepoolwithrealrandos(self.poolsize)

    def fillthepoolSHA256CounterMode(self,poolsize):
        for i in range(poolsize):
            # we put the counter value i in the hash function
            # and add it to the pool
            i=i
            self.poolofsha256randos.append(self.sha256(bytes(i)))
        return self.poolofsha256randos
    
    def fillthepoolwithrealrandos(self,poolsize):
        for i in range(poolsize):
            i=i
            self.poolofrealrandos.append(bytes(self.secretshash()))
        return self.poolofrealrandos

    def sha256(self,keybytes:bytes,encoding =  "utf-8"):
        ''' returns a sha256 digest of a string'''
        herp = hashlib.sha256()
        herp.update(keybytes)
        return herp.digest()

    def secretshash(self,bitsize = 32):
        return secrets.randbits(bitsize)

class EntropyPool():
    '''Holds A pool of entropic value
Final pool is held in self.output
'''
    def __init__(self, bytesize:int, method = "xor"):
        #setup the system in order
        self.pool = []
        self.bytesize = bytesize
        self.output = list

    def SaltMine(self, bytesize, number_of_itterations, seed):
        '''Derives good random numbers from a variety of sources
    - Will itterate the operation the specified number of times
    - Performs an XOR Shuffle on a set of PRN generated by a Mersenne Twister'''
        try:
            xorstuff = XORShift()
            # setup the mersenne twister to begin generating numbers
            twister = MersenneTwist()
            twister.seedtwister(seed)
            for x in range(number_of_itterations):
                #unused variable error
                x = x
                self.pool.append(twister.extract_number())
            # once we have filled the pool, with PRN from the twister
            # we can then filter them through a 
            for seedbytes in self.pool:
                self.output.append(xorstuff.XORBox(seedbytes, number_of_itterations))

        except Exception:
            errorprinter("[-] Could not get, any more Random than this. Sorry... THROW A BANANA!")

class EntropyPoolHandler():
    '''Entropy Pool management
    Will Create an EntropyPool() Class and seed it with a decent set of random data,
    from pre-established sources of known good Pseudo Random Numbers.

    Mersenne Twisters require a 32bit word length

This is the Function to call externally'''
    def __init__(self, bytearraylength = 32, poolsize = 32):
        source = source1(bytearraylength)
        # scalingfactor = 1
        # we need to perform sorting operations and metrics so 
        # we instantiate multiple handlers to perform those operations
        self.Pool = EntropyPool(bytearraylength)
        self.Pool.SaltMine(bytearraylength, source, source)

    def uniformity(self, x):
        '''Will return a number describing the uniformity of the data fed to it
    Accepts arrays of integers/floats'''
        return lambda x : 1 - 0.5*sum( abs(x - numpy.average(x)) )/(len(x)*numpy.average(x))
    
    def check_uniformity(self):
        '''In statistics, the bias (or bias function) of an estimator is the 
    difference between this estimator's expected value and the true value of the
    parameter being estimated. An estimator or decision rule with zero bias is 
    called unbiased. In statistics, "bias" is an objective property of an estimator.
    Bias can also be measured with respect to the median, rather than the mean 
    (expected value), in which case one distinguishes median-unbiased from the 
    usual mean-unbiasedness property.'''
        uniformityarray = []
        for csprn in self.Pool.pool:
            # comparing csprn from pool to csprn after uniformity c
            #we have to compare each number for the distance between the values
            # we save the value representing the distance between the  two
            # in its own array and average those into one number, representing 
            # the bias, we want numbers close to 0?
            uniformityarray.append(self.uniformity(csprn))
